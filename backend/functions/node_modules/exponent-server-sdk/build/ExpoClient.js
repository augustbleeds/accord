'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toArray2 = require('babel-runtime/helpers/toArray');

var _toArray3 = _interopRequireDefault(_toArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _nodeFetch = require('node-fetch');

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BASE_URL = 'https://exp.host'; /**
                                    * expo-server-sdk
                                    *
                                    * Use this if you are running Node on your server backend when you are working
                                    * with Expo
                                    * https://expo.io
                                    *
                                    * 
                                    */

var BASE_API_URL = BASE_URL + '/--/api/v2';

/**
 * The max number of push notifications to be sent at once. Since we can't
 * automatically upgrade everyone using this library, we should strongly try not
 * to decrease it.
 */
var PUSH_NOTIFICATION_CHUNK_LIMIT = 100;

// TODO: Eventually we'll want to have developers authenticate. Right now it's
// not necessary because push notifications are the only API we have and the
// push tokens are secret anyway.

var ExpoClient = function () {
  function ExpoClient() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, ExpoClient);

    this._httpAgent = options.httpAgent;
  }

  /**
   * Returns `true` if the token is an Expo push token
   */


  (0, _createClass3.default)(ExpoClient, [{
    key: 'sendPushNotificationAsync',


    /**
     * Sends the given message to its recipient via a push notification
     */
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(message) {
        var receipts;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.sendPushNotificationsAsync([message]);

              case 2:
                receipts = _context.sent;

                (0, _invariant2.default)(receipts.length === 1, 'Expected exactly one push receipt');
                return _context.abrupt('return', receipts[0]);

              case 5:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function sendPushNotificationAsync(_x2) {
        return _ref.apply(this, arguments);
      }

      return sendPushNotificationAsync;
    }()

    /**
     * Sends the given messages to their recipients via push notifications and
     * returns an array of push receipts. Each receipt corresponds to the message
     * at its respective index (the nth receipt is for the nth message).
     *
     * There is a limit on the number of push notifications you can send at once.
     * Use `chunkPushNotifications` to divide an array of push notification
     * messages into appropriately sized chunks.
     */

  }, {
    key: 'sendPushNotificationsAsync',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(messages) {
        var data, apiError;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._requestAsync(BASE_API_URL + '/push/send', {
                  httpMethod: 'post',
                  body: messages,
                  shouldCompress: function shouldCompress(body) {
                    return body.length > 1024;
                  }
                });

              case 2:
                data = _context2.sent;

                if (!(!Array.isArray(data) || data.length !== messages.length)) {
                  _context2.next = 7;
                  break;
                }

                apiError = new Error('Expected Exponent to respond with ' + messages.length + ' ' + ((messages.length === 1 ? 'receipt' : 'receipts') + ' but got ') + ('' + data.length));

                apiError.data = data;
                throw apiError;

              case 7:
                return _context2.abrupt('return', data);

              case 8:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sendPushNotificationsAsync(_x3) {
        return _ref2.apply(this, arguments);
      }

      return sendPushNotificationsAsync;
    }()
  }, {
    key: 'chunkPushNotifications',
    value: function chunkPushNotifications(messages) {
      var chunks = [];
      var chunk = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = messages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _message = _step.value;

          chunk.push(_message);
          if (chunk.length >= PUSH_NOTIFICATION_CHUNK_LIMIT) {
            chunks.push(chunk);
            chunk = [];
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (chunk.length) {
        chunks.push(chunk);
      }

      return chunks;
    }
  }, {
    key: '_requestAsync',
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(url, options) {
        var sdkVersion, fetchOptions, json, response, apiError, result, _apiError, _apiError2;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                sdkVersion = require('../package.json').version;
                fetchOptions = {
                  method: options.httpMethod,
                  body: JSON.stringify(options.body),
                  headers: new _nodeFetch.Headers({
                    'Accept': 'application/json',
                    'Accept-Encoding': 'gzip, deflate',
                    'User-Agent': 'exponent-server-sdk-node/' + sdkVersion
                  }),
                  agent: this._httpAgent
                };

                if (!(options.body != null)) {
                  _context3.next = 14;
                  break;
                }

                json = JSON.stringify(options.body);

                (0, _invariant2.default)(json != null, 'JSON request body must not be null');

                if (!options.shouldCompress(json)) {
                  _context3.next = 12;
                  break;
                }

                _context3.next = 8;
                return _gzipAsync(Buffer.from(json));

              case 8:
                fetchOptions.body = _context3.sent;

                fetchOptions.headers.set('Content-Encoding', 'gzip');
                _context3.next = 13;
                break;

              case 12:
                fetchOptions.body = json;

              case 13:

                fetchOptions.headers.set('Content-Type', 'application/json');

              case 14:
                _context3.next = 16;
                return (0, _nodeFetch2.default)(url, fetchOptions);

              case 16:
                response = _context3.sent;

                if (!(response.status !== 200)) {
                  _context3.next = 22;
                  break;
                }

                _context3.next = 20;
                return this._parseErrorResponseAsync(response);

              case 20:
                apiError = _context3.sent;
                throw apiError;

              case 22:

                // We expect the API response body to be JSON
                result = void 0;
                _context3.prev = 23;
                _context3.next = 26;
                return response.json();

              case 26:
                result = _context3.sent;
                _context3.next = 35;
                break;

              case 29:
                _context3.prev = 29;
                _context3.t0 = _context3['catch'](23);
                _context3.next = 33;
                return this._getTextResponseErrorAsync(response);

              case 33:
                _apiError = _context3.sent;
                throw _apiError;

              case 35:
                if (!result.errors) {
                  _context3.next = 38;
                  break;
                }

                _apiError2 = this._getErrorFromResult(result);
                throw _apiError2;

              case 38:
                return _context3.abrupt('return', result.data);

              case 39:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[23, 29]]);
      }));

      function _requestAsync(_x4, _x5) {
        return _ref3.apply(this, arguments);
      }

      return _requestAsync;
    }()
  }, {
    key: '_parseErrorResponseAsync',
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(response) {
        var result, apiError;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                result = void 0;
                _context4.prev = 1;
                _context4.next = 4;
                return response.json();

              case 4:
                result = _context4.sent;
                _context4.next = 12;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4['catch'](1);
                _context4.next = 11;
                return this._getTextResponseErrorAsync(response);

              case 11:
                return _context4.abrupt('return', _context4.sent);

              case 12:
                if (!(!result.errors || !Array.isArray(result.errors) || !result.errors.length)) {
                  _context4.next = 18;
                  break;
                }

                _context4.next = 15;
                return this._getTextResponseErrorAsync(response);

              case 15:
                apiError = _context4.sent;

                apiError.errorData = result;
                return _context4.abrupt('return', apiError);

              case 18:
                return _context4.abrupt('return', this._getErrorFromResult(result));

              case 19:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 7]]);
      }));

      function _parseErrorResponseAsync(_x6) {
        return _ref4.apply(this, arguments);
      }

      return _parseErrorResponseAsync;
    }()
  }, {
    key: '_getTextResponseErrorAsync',
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(response) {
        var text, apiError;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return response.text();

              case 2:
                text = _context5.sent;
                apiError = new Error('Exponent responded with an error with status code ' + response.status + ': ' + text);

                apiError.statusCode = response.status;
                apiError.errorText = text;
                return _context5.abrupt('return', apiError);

              case 7:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _getTextResponseErrorAsync(_x7) {
        return _ref5.apply(this, arguments);
      }

      return _getTextResponseErrorAsync;
    }()

    /**
     * Returns an error for the first API error in the result, with an optional
     * `others` field that contains any other errors.
     */

  }, {
    key: '_getErrorFromResult',
    value: function _getErrorFromResult(result) {
      var _this = this;

      (0, _invariant2.default)(result.errors && result.errors.length > 0, 'Expected at least one error from Exponent');

      var _result$errors = (0, _toArray3.default)(result.errors),
          errorData = _result$errors[0],
          otherErrorData = _result$errors.slice(1);

      var error = this._getErrorFromResultError(errorData);
      if (otherErrorData.length) {
        error.others = otherErrorData.map(function (data) {
          return _this._getErrorFromResultError(data);
        });
      }
      return error;
    }

    /**
     * Returns an error for a single API error
     */

  }, {
    key: '_getErrorFromResultError',
    value: function _getErrorFromResultError(errorData) {
      var error = new Error(errorData.message);
      error.code = errorData.code;

      if (errorData.details != null) {
        error.details = errorData.details;
      }

      if (errorData.stack != null) {
        error.serverStack = errorData.stack;
      }

      return error;
    }
  }], [{
    key: 'isExpoPushToken',
    value: function isExpoPushToken(token) {
      return typeof token === 'string' && token.startsWith('ExponentPushToken[') && token.endsWith(']');
    }

    /**
     * Legacy alias for isExpoPushToken
     */

  }, {
    key: 'isExponentPushToken',
    value: function isExponentPushToken(token) {
      return ExpoClient.isExpoPushToken(token);
    }
  }]);
  return ExpoClient;
}();

ExpoClient.pushNotificationChunkSizeLimit = PUSH_NOTIFICATION_CHUNK_LIMIT;
exports.default = ExpoClient;


function _gzipAsync(data) {
  return new Promise(function (resolve, reject) {
    _zlib2.default.gzip(data, function (error, result) {
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    });
  });
}

module.exports = exports['default'];
//# sourceMappingURL=ExpoClient.js.map