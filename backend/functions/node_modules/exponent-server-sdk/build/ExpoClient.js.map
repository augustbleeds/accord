{"version":3,"sources":["../src/ExpoClient.js"],"names":["BASE_URL","BASE_API_URL","PUSH_NOTIFICATION_CHUNK_LIMIT","ExpoClient","options","_httpAgent","httpAgent","message","sendPushNotificationsAsync","receipts","length","messages","_requestAsync","httpMethod","body","shouldCompress","data","Array","isArray","apiError","Error","chunks","chunk","push","url","sdkVersion","require","version","fetchOptions","method","JSON","stringify","headers","agent","json","_gzipAsync","Buffer","from","set","response","status","_parseErrorResponseAsync","result","_getTextResponseErrorAsync","errors","_getErrorFromResult","errorData","text","statusCode","errorText","otherErrorData","error","_getErrorFromResultError","others","map","code","details","stack","serverStack","token","startsWith","endsWith","isExpoPushToken","pushNotificationChunkSizeLimit","Promise","resolve","reject","gzip"],"mappings":"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","file":"ExpoClient.js","sourcesContent":["/**\n * expo-server-sdk\n *\n * Use this if you are running Node on your server backend when you are working\n * with Expo\n * https://expo.io\n *\n * @flow\n */\nimport invariant from 'invariant';\nimport fetch, { Headers, Response as FetchResponse } from 'node-fetch';\nimport zlib from 'zlib';\n\nconst BASE_URL = 'https://exp.host';\nconst BASE_API_URL = `${BASE_URL}/--/api/v2`;\n\n/**\n * The max number of push notifications to be sent at once. Since we can't\n * automatically upgrade everyone using this library, we should strongly try not\n * to decrease it.\n */\nconst PUSH_NOTIFICATION_CHUNK_LIMIT = 100;\n\n// TODO: Eventually we'll want to have developers authenticate. Right now it's\n// not necessary because push notifications are the only API we have and the\n// push tokens are secret anyway.\nexport default class ExpoClient {\n  static pushNotificationChunkSizeLimit = PUSH_NOTIFICATION_CHUNK_LIMIT;\n\n  _httpAgent: ?HttpAgent;\n\n  constructor(options: ExpoClientOptions = {}) {\n    this._httpAgent = options.httpAgent;\n  }\n\n  /**\n   * Returns `true` if the token is an Expo push token\n   */\n  static isExpoPushToken(token: ExpoPushToken): boolean {\n    return (typeof token === 'string') &&\n      token.startsWith('ExponentPushToken[') &&\n      token.endsWith(']');\n  }\n\n  /**\n   * Legacy alias for isExpoPushToken\n   */\n  static isExponentPushToken(token: ExpoPushToken): boolean {\n    return ExpoClient.isExpoPushToken(token);\n  }\n\n  /**\n   * Sends the given message to its recipient via a push notification\n   */\n  async sendPushNotificationAsync(\n    message: ExpoPushMessage,\n  ): Promise<ExpoPushReceipt> {\n    let receipts = await this.sendPushNotificationsAsync([message]);\n    invariant(receipts.length === 1, `Expected exactly one push receipt`);\n    return receipts[0];\n  }\n\n  /**\n   * Sends the given messages to their recipients via push notifications and\n   * returns an array of push receipts. Each receipt corresponds to the message\n   * at its respective index (the nth receipt is for the nth message).\n   *\n   * There is a limit on the number of push notifications you can send at once.\n   * Use `chunkPushNotifications` to divide an array of push notification\n   * messages into appropriately sized chunks.\n   */\n  async sendPushNotificationsAsync(\n    messages: ExpoPushMessage[],\n  ): Promise<ExpoPushReceipt[]> {\n    let data = await this._requestAsync(`${BASE_API_URL}/push/send`, {\n      httpMethod: 'post',\n      body: messages,\n      shouldCompress(body) {\n        return body.length > 1024;\n      },\n    });\n\n    if (!Array.isArray(data) || data.length !== messages.length) {\n      let apiError: Object = new Error(\n        `Expected Exponent to respond with ${messages.length} ` +\n        `${messages.length === 1 ? 'receipt' : 'receipts'} but got ` +\n        `${data.length}`,\n      );\n      apiError.data = data;\n      throw apiError;\n    }\n\n    return data;\n  }\n\n  chunkPushNotifications(\n    messages: ExpoPushMessage[],\n  ): ExpoPushMessage[][] {\n    let chunks = [];\n    let chunk = [];\n    for (let message of messages) {\n      chunk.push(message);\n      if (chunk.length >= PUSH_NOTIFICATION_CHUNK_LIMIT) {\n        chunks.push(chunk);\n        chunk = [];\n      }\n    }\n\n    if (chunk.length) {\n      chunks.push(chunk);\n    }\n\n    return chunks;\n  }\n\n  async _requestAsync(\n    url: string,\n    options: RequestOptions,\n  ): Promise<*> {\n    let sdkVersion = require('../package.json').version;\n    let fetchOptions = {\n      method: options.httpMethod,\n      body: JSON.stringify(options.body),\n      headers: new Headers({\n        'Accept': 'application/json',\n        'Accept-Encoding': 'gzip, deflate',\n        'User-Agent': `exponent-server-sdk-node/${sdkVersion}`,\n      }),\n      agent: this._httpAgent,\n    };\n    if (options.body != null) {\n      let json = JSON.stringify(options.body);\n      invariant(json != null, `JSON request body must not be null`);\n      if (options.shouldCompress(json)) {\n        fetchOptions.body = await _gzipAsync(Buffer.from(json));\n        fetchOptions.headers.set('Content-Encoding', 'gzip');\n      } else {\n        fetchOptions.body = json;\n      }\n\n      fetchOptions.headers.set('Content-Type', 'application/json');\n    }\n\n    let response = await fetch(url, fetchOptions);\n\n    if (response.status !== 200) {\n      let apiError = await this._parseErrorResponseAsync(response);\n      throw apiError;\n    }\n\n    // We expect the API response body to be JSON\n    let result: ApiResult;\n    try {\n      result = await response.json();\n    } catch (e) {\n      let apiError = await this._getTextResponseErrorAsync(response);\n      throw apiError;\n    }\n\n    if (result.errors) {\n      let apiError = this._getErrorFromResult(result);\n      throw apiError;\n    }\n\n    return result.data;\n  }\n\n  async _parseErrorResponseAsync(response: FetchResponse): Promise<Error> {\n    let result: ApiResult;\n    try {\n      result = await response.json();\n    } catch (e) {\n      return await this._getTextResponseErrorAsync(response);\n    }\n\n    if (!result.errors || !Array.isArray(result.errors) || !result.errors.length) {\n      let apiError: Object = await this._getTextResponseErrorAsync(response);\n      apiError.errorData = result;\n      return apiError;\n    }\n\n    return this._getErrorFromResult(result);\n  }\n\n  async _getTextResponseErrorAsync(response: FetchResponse): Promise<Error> {\n    let text = await response.text();\n    let apiError: Object = new Error(\n      `Exponent responded with an error with status code ${response.status}: ` +\n      text,\n    );\n    apiError.statusCode = response.status;\n    apiError.errorText = text;\n    return apiError;\n  }\n\n  /**\n   * Returns an error for the first API error in the result, with an optional\n   * `others` field that contains any other errors.\n   */\n  _getErrorFromResult(result: ApiResult): Error {\n    invariant(\n      result.errors && result.errors.length > 0,\n      `Expected at least one error from Exponent`,\n    );\n    let [errorData, ...otherErrorData] = (result.errors);\n    let error: Object = this._getErrorFromResultError(errorData);\n    if (otherErrorData.length) {\n      error.others = otherErrorData.map(\n        data => this._getErrorFromResultError(data),\n      );\n    }\n    return error;\n  }\n\n  /**\n   * Returns an error for a single API error\n   */\n  _getErrorFromResultError(errorData: ApiResultError): Error {\n    let error: Object = new Error(errorData.message);\n    error.code = errorData.code;\n\n    if (errorData.details != null) {\n      error.details = errorData.details;\n    }\n\n    if (errorData.stack != null) {\n      error.serverStack = errorData.stack;\n    }\n\n    return error;\n  }\n}\n\nfunction _gzipAsync(data: Buffer): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    zlib.gzip(data, (error, result) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\nexport type ExpoClientOptions = {\n  httpAgent?: HttpAgent,\n};\n\ntype HttpAgent = Object;\n\nexport type ExpoPushToken = string;\n\nexport type ExpoPushMessage = {\n  to: ExpoPushToken,\n  data?: Object,\n  title?: string,\n  body?: string,\n  sound?: 'default' | null,\n  ttl?: number,\n  expiration?: number,\n  priority?: 'default' | 'normal' | 'high',\n  badge?: number,\n};\n\nexport type ExpoPushReceipt = {\n  status: 'ok' | 'error',\n  details?: {\n    error?: 'DeviceNotRegistered' | 'MessageTooBig' | 'MessageRateExceeded',\n  },\n  // Internal field used only by developers working on Expo\n  __debug?: any,\n};\n\ntype RequestOptions = {\n  httpMethod: 'get' | 'post',\n  body?: any,\n  shouldCompress: (body: string) => boolean,\n};\n\ntype ApiResult = {\n  errors?: ApiResultError[],\n  data?: any,\n};\n\ntype ApiResultError = {\n  message: string,\n  code: string,\n  details?: any,\n  stack?: string,\n};\n"]}